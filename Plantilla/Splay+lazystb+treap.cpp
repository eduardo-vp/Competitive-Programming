// Kotaro << Minoz << Hayama << Cohr3141592654
 
// Fall...
 
// You know, everybody's been tellin' me what they think about me for the last few months
 
// ... It's too loud
// Maybe it's time I tell 'em what I think about them
// ... Can't hear it coming down the hallway stairs from the parking lot
// ... It's too loud
// ... Three's not a crowd all up in it, slow fire
 
// ... Don't fall on my face
// ... Don't fall on my faith, oh
// ... Don't fall on my fate
// ... Don't fall on my faith, oh
// ... Don't fall on my fate
// ... Don't fall on my
 
// Gotta concentrate, against the clock I race
// Got no time to waste, I'm already late, I got a marathoner's pace
// Went from addict to a workaholic, word to Dr. Dre
// In that first marijuana tape-guess I got a chronic case (yeah)
// And I ain't just blowin' smoke, 'less it's in your momma's face
// I know this time Paul and Dre
// They won't tell me what not to say (nope)
// And though me and my party days
// Have all pretty much parted ways
// You'd swear to God I forgot I'm the guy that made "Not Afraid"
// One last time for Charlamagne
// If my response is late, it's just how long it takes
// To hit my fuckin' radar, I'm so far away
// These rappers are like Hunger Games
// One minute, they're mockin' Jay
// Next minute, they get their style from Migos or they copy Drake
// Maybe I just don't know when to turn around and walk away
// But all the hate, I call it "Walk on Water" gate
// I've had as much as I can tolerate
// I'm sick and tired of waitin', I done lost my patience
// I can take all of you motherfuckers on at once
// You wanted Shady? You got him!
 
// ... Don't fall on my face (yeah)
// ... Don't fall on my faith, oh
// ... Don't fall on my fate (line 'em up!)
// ... Don't fall on my faith, oh (rrr!)
// ... Don't fall on my fate (look)
 
// Somebody tell Budden before I snap, he better fasten it
// Or have his body bag get zipped
// The closest thing he's had to hits is smackin' bitches
// And don't make me have to give it back to Akademiks
// Say this shit is trash again, I'll have you twisted
// Like you had it when you thought you had me slippin' at the telly
// Even when I'm gettin' brain, you'll never catch me with a thot
// Lackin' with it, "he ain't spittin' like this on his last shit"
// Ho, you better go back and listen
// You know me better, thinkin' I'll slow or let up
// Call it trap 'cause it's a total setup
// Hopin' that you rappers fall in that
// Dre said, "Hold your head up!"â��Kathy Griffin
// Stackin' ammunition, slap the clip in, cock it back on competition
// This is how I shot ahead (pew)â��Gabby Giffords
// My attack is vicious, Jack the Ripper, back in business
// Tyler create nothin', I see why you called yourself a (faggot), bitch
// It's not just 'cause you lack attention
// It's because you worship D12's balls, you're sack-religious
// If you're gonna critique me
// You better at least be as good or better
// Get Earl the Hooded Sweater
// Whatever his name is to help you put together
// Some words, more than just two letters
// The fans waited for this moment like that feature
// When I stole the show (ha), sorry if I took forever (haha)
 
// ... Don't fall on my face (yeah)
// ... Don't fall on my faith, oh (I won't)
// ... Don't fall on my fate (line 'em up!)
// ... Don't fall on my faith, oh (ha)
// ... Don't fall on my fate (it's too easy)
 
// Just remember, I was here before you
// And I'll be here after you make your run-in for you
// Detractors, I might have to fuck Pitchfork with a corkscrew
// Just what the doctor ordered
// Revenge is the best medicine
// Increase the dose, from least to most
// And then tell the Grammys to go and fuck themselves
// They suck the blood from all the biggest artists like some leeches
// So they nominate 'em, get 'em there, get a name to MC the show
// Every parasite needs a host (haha)
// Then give Album of the Year to somebody that no one's ever even heard of
// All I know is I wrote every single word of
// Everything I ever murdered
// Time to separate the sheep from goats (yeah)
// And I got no faith in your writers, I don't believe in ghosts
// When rap needed it most, I was that wing and a prayer
// A beacon of hope, put a B-I-R-D in the air
// Somewhere some kid is bumpin' this while he lip-syncs in the mirror
// That's who I'm doin' it for, the rest I don't really even care
// But you would think I'm carryin' a Oxford dictionary in my pocket
// How I'm buryin' these artists
// On a scale of 'turnt' you're 'minus'
// Mine says 'very', yours says 'hardly'
// And what's scary is you probably can compare me to your car 'cause I'm just barely gettin' started (woo)
// And far as Lord Jamar, you better leave me the hell alone
// Or I'll show you an Elvis clone
// Walk up in this house you own, thrust my pelvic bone
// Use your telephone and go fetch me the remote
// Put my feet up and just make myself at home
// I belong here, clown, don't tell me 'bout the culture
// I inspired the Hopsins, the Logics, the Coles, the
// Seans, the K-Dots, the 5'9"s, and oh
// Brought the world 50 Cent, you did squat, piss and moan
// But I'm not gonna fall... bitch!
 
// ... It's too loud
// ... Can't hear it coming down the hallway stairs from the parking lot
// ... It's too loud
// ... Three's not a crowd all up in it
// ... Slow fire
 
 
// #pragma GCC optimize ("Ofast,unroll-loops")
// #pragma GCC target ("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native")
#include <bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#define pb push_back
#define ff  first
#define ss second
#define tm1 first
#define tm2 second.first
#define tm3 second.second
#define sz(x) int(x.size())
#define fill(x, v) memset(x, v, sizeof(x))
#define all(v) (v).begin(), (v).end()
#define FER(i,a,b) for(ll i=ll(a); i< ll(b); ++i)
#define IFR(i,a,b) for(ll i=ll(a); i>=ll(b); --i )
#define fastio ios_base::sync_with_stdio(0); cin.tie(0)
 
#define N 100005
#define MOD 1000000007
#define N1 105
#define sqr(x) (x)*(x)
#define INF 2000000000
 
using namespace std;
using namespace __gnu_pbds;
 
typedef int ll;
typedef pair<ll, ll> ii;
typedef pair<ll, ii > tri;
typedef vector<ll> vi;
typedef vector<ii> vii;
typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> set_t;
 
#define trace(...) f(#__VA_ARGS__, __VA_ARGS__)
 
template<typename t> void f(const char* x, t&& val1){
    cout<<x<< " : "<<val1<<endl;
}
template<typename t1, typename... t2> void f(const char* x, t1&& val1, t2&&... val2){
    const char* xd=strchr(x+1, ',');
    cout.write(x, xd-x)<<" : "<<val1<<" | ";
    f(xd+1, val2...);
}
 
//-----------------------------------------------
//Lazy splay tree propagation
//make -> n, preprocess() y build()
//Be careful about the lazy push values 
 
struct Node{
    Node *child[2], *p;
    bool t;
    ll val, ta, sum, add, l, r, mid; //mx, l, r, mid;
    inline void clear(){
        l=-INF;
    }
};
 
struct SplayTree{
    Node *nil, *root;
    ll ar[N], n;
    inline void preprocess(){
        nil=new Node();
        nil->child[0] = nil->child[1] = nil->p=nil;
        nil->val=nil->ta=nil->sum=0;
        nil->t=false;
        nil->add=0;
        // nil->mx=-INF;
        nil->l=-INF;
        nil->r=-INF;
        nil->mid=-INF;
        root=nil;
    }
    inline Node* Op(Node *x, Node *y){
        if(x==nil) return y;
        if(y==nil) return x;
        Node *ty=new Node();
        ty->sum=x->sum+y->sum;
        ty->l=max(x->l, x->sum+y->l);
        ty->r=max(y->r, x->r+y->sum);
        ty->mid=max(ty->l, max(ty->r, max(x->mid, max(y->mid, x->r+y->l))));
        return ty;
    }
    inline void upd(Node *x){
        Node *cur=new Node();
        cur->l=x->val, cur->r=x->val, cur->mid=x->val, cur->sum=x->val;
        cur=Op(x->child[0], cur);
        cur=Op(cur, x->child[1]);
        x->l=cur->l;
        x->r=cur->r;
        x->sum=cur->sum;
        x->mid=cur->mid;
        x->ta=x->child[0]->ta + x->child[1]->ta+1;
        // x->mx=max(x->child[0]->mx, max(x->child[1]->mx, x->mx));
    }
    inline void updpro(Node * x, ll val){
        x->add+=val;
        x->val+=val;
        // x->mx+=val;
        x->sum+=x->ta*val;
        x->mid+=x->ta*val;
        x->l+=x->ta*val;
        x->r+=x->ta*val;
    }
    inline void push(Node *x){
        if(x==nil) return;
        if(x->add!=0){
            if(x->child[0]!=nil) updpro(x->child[0], x->add);
            if(x->child[1]!=nil) updpro(x->child[1], x->add);
            x->add=0;
        }
        if(x->t){
            swap(x->child[0], x->child[1]);
            x->child[0]->t=!x->child[0]->t;
            x->child[1]->t=!x->child[1]->t;
            x->t=false;
        }
    }
    inline void set(Node *x, Node *y, ll d){
        x->child[d]=y;
        y->p=x;
    }
    inline ll get(Node *x, Node *y){
        return x->child[0]==y? 0 : 1;
    }
    inline ll rot(Node *x, ll d){
        Node *y=x->child[d], *z=x->p;
        set(x, y->child[d^1], d);
        set(y, x, d^1);
        set(z, y, get(z, x));
        upd(x), upd(y);
    }
    inline void splay(Node *x){
        push(x);
        while(x->p != nil){
            Node *y=x->p, *z=y->p;
            ll dy=get(y, x), dz=get(z, y);
            if(z==nil) rot(y, dy);
            else if(dy==dz) rot(z, dz), rot(y, dy);
            else rot(y, dy), rot(z, dz);
        }
        upd(x);
    }
    inline Node * getnode(Node *x, ll pos){
        while(push(x), x->child[0]->ta!=pos){
            pos<x->child[0]->ta? x=x->child[0]: (pos-=x->child[0]->ta+1, x=x->child[1]);
        }
        return splay(x), x;
    }
    inline void split(Node *x, ll l, Node * &t1, Node * &t2){
        if(l==0) t1=nil, t2=x;
        else{
            t1=getnode(x, l-1);
            t2=t1->child[1];
            t1->child[1]=t2->p =nil;
            upd(t1);
        }
    }
    inline Node * unir(Node *x, Node *y){
        if(x==nil) return y;
        x=getnode(x, x->ta-1);
        set(x, y, 1);
        upd(x);
        return x;
    }
    inline void AddRange(ll l, ll r, ll add){
        Node *t1, * t2, * t3;
        split(root, r, t1, t3);
        split(t1, l, t1, t2);
        t2->add+=add;
        t2->val+=add;
        t2->sum+=t2->ta * add;
        // t2->mx+=val;
        root=unir(t1, unir(t2, t3));
    }
    inline void modify(ll pos, ll val){
        root=getnode(root, pos);
        root->val=val;
        upd(root);
    }
    inline void AddVal(ll pos, ll val){
        Node *t1, *t2;
        Node *cur=new Node();
        cur->val=val, cur->p=nil, cur->t=false;
        cur->l=val, cur->r=val, cur->mid=val, cur->sum=val;//, cur->mx=val;
        cur->ta=1;
        cur->child[0]=cur->child[1]=nil;
        ll r=pos;
        if(r==root->ta || r==0){
            if(r==0) root=unir(cur, root);
            else root=unir(root, cur);
            return;
        }
        split(root, r, t1, t2);
        root=unir(unir(t1, cur), t2);
    } 
    inline void DelVal(ll pos){
        Node *t1, *t2, *t3;
        ll l=pos, r=pos+1;
        if(l==0 || r==root->ta){
            if(l==0){
                split(root, r, t1, t2);
                root=unir(nil, t2);
            }
            else{
                split(root, l, t1, t2);
                root=unir(t1, nil);
            }
            return;
        } 
        split(root, r, t1, t3);
        split(t1, l, t1, t2);
        root=unir(t1, t3);
        return;
    }
    inline void Reverse(ll l, ll r){
        Node * t1, * t2, * t3;
        split(root, r, t1, t3);
        split(t1, l, t1, t2);
        t2->t=!t2->t;
        root=unir(unir(t1, t2), t3);
    }
    inline void move(ll l, ll r, ll l1, ll r1){
        Node *t1, *t2, *t3, *t4, *t5;
        split(root, r1, t4, t5);
        split(t4, l1, t3, t4);
        split(t3, r, t2, t3);
        split(t2, l, t1, t2);
        root=unir(unir(t1,unir(t4, t3)), unir(t2, t5));
    }
    inline ll que(ll l, ll r){
        Node *t1, * t2, *t3;
        split(root, r, t1, t3);
        split(t1, l, t1, t2);
        ll ans=t2->mid;
        root=unir(unir(t1, t2), t3);
        return ans;
    }
    inline Node * build1(ll l, ll r){
        if(l==r) return nil;
        ll mid=(l+r)>>1;
        Node *x=new Node();
        x->val=ar[mid];
        x->l=ar[mid];
        x->r=ar[mid];
        x->mid=ar[mid];
        x->sum=ar[mid];
        // x->mx=ar[mid];
        x->p=nil;
        x->t=false;
        x->add=0;
        set(x, build1(l, mid), 0);
        set(x, build1(mid+1, r), 1);
        upd(x);
        return x;
    }
    inline void build(){
        Node *root1=build1(0, n);
        root=root1;
    }
}st;
 
inline void ss(){
    ll ta=st.root->ta;
    FER(i,0,ta){
        ll ja=st.que(i, i+1);
        trace(i, ja);
    }
}
int main(){
    fastio;
    ll n; scanf("%d", &n);//cin>>n;
    st.n=n;
    FER(i,0,n) scanf("%d", &st.ar[i]);//cin>>st.ar[i];
    st.preprocess();
    st.build();
    ll q, l, r; scanf("%d", &q);//cin>>q;
    char s;
    FER(i,0,q){
        scanf(" %c", &s);//cin>>s;
        if(s=='I'){
            scanf("%d%d", &l, &r); l--;//cin>>l>>r; l-=2;
            st.AddVal(l, r);
        }
        else if(s=='D'){
            scanf("%d", &l); l--;//cin>>l; l--;
            st.DelVal(l);
        }
        else if(s=='R'){
            scanf("%d%d", &l, &r); l--; //cin>>l>>r; l--;
            st.modify(l, r);
        }
        else if(s=='Q'){
            scanf("%d%d", &l, &r); l--;
            ll froz=st.que(l, r);
            printf("%d\n", froz);
        }
    }
    return 0;
}  
